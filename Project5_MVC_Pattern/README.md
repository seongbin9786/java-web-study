# 1강

## 11부 - MVC 패턴

1. MVC는 Model-View-Controller 의 약자로, 세 계층으로 프로그램을 나누는 패턴이다. MVC 패턴은 주로 웹 환경에서 사용되지만 UI가 있는 어떤 형태의 프로그램에서도 사용할 수 있다. MVC 패턴은 타입1, 2가 있지만, 타입 1에 대한 설명은 생략한다.

2. MVC 패턴은 프로그램의 비즈니스 로직(프로그램에서 제공하는 실질적인 기능)과 뷰(UI 소스 코드)를 계층을 나누어 분리하게 된다.

3. Java 웹 개발에서는 Model 계층에서 비즈니스 로직을 구현하게 되며, Controller 계층에서 Servlet이 요청과 응답을 담당하게 되고, JSP가 코드가 View 계층을 구성한다.

4. 컨트롤러 계층: 컨트롤러 객체는 요청을 받은 후 요청에서 요구하는 기능을 잘 수행할 Model 계층의 객체에 위임하고, 결과를 응답에 실어 보내게 된다.

5. 모델 계층: 모델 객체는 컨트롤러에 의해 호출되며 입력을 받고 일련의 처리를 거쳐 출력물을 내놓는 역할을 한다. 이 때 처리가 비즈니스 로직이어야 한다.

6. 비즈니스 로직: 프로그램에서 제공하는 실질적인 기능이다. MVC에서 로그인 등의 기능은 Controller 혹은 View에서 처리하지 않고, Controller가 Model에 위임한 후 Model이 기능을 처리하게 된다.

7. 뷰 계층: View 계층은 Model의 정보를 받아 그 정보를 토대로 화면을 그리는 역할이다. Java Web 개발에서는 JSP가 Servlet이 forward한 request 객체에 포함된 Model 객체들에 접근하여 그 값들로 일련의 처리를 하여 화면을 그리게 된다.

8. MVC는 설명도 추상적이고 이해하는 입장에서도 듣고 보면 당연한 이야기 같을 수 있다. 굳이 패턴이 있을 정나? 왜 그렇게 안하지? 싶을 수 있지만, MVC 패턴을 적용하지 않은 예제 프로젝트를 진행한 후 MVC 패턴을 적용하여 프로젝트를 진행해봐야 그 차이를 느낄 수 있게 된다.

9. JSP에서 거의 모든 로직을 처리할 수 있는데(JSP에서 Java Code를 실행할 수 있기 때문이다), 이것은 View 코드와 비즈니스 로직이 섞인 형태가 되고 따라서 MVC 패턴이 아니다. 해당 JSP 파일은 유지보수가 거의 불가능해지는 시점이 오게 되는데,

    1. 해당 파일에서 많은 일을 처리하기 때문에 복잡도가 증가하여 이해가 힘들어진다. 즉 어느 정도의 시간이 흐른 뒤 해당 코드를 수정하려면 긴 호흡의 코드를 쭉 읽고 이해해야 하는 상황이 온다.

    2. 복잡성이 증가하면 자연히 다른 구성요소와 결합이 강해지게 되는데, 다른 구성요소들을 수정할 때 마다 해당 파일도 수정과 테스트를 진행해야 한다.

    3. 같은 파일을 View를 담당하는 프로그래머, Business Logic을 담당하는 프로그래머가 동시에 만져야 할 때가 종종 발생할 수 있는데, 동시에 같은 파일을 작업하는 것은 git을 사용하더라도 수동으로 충돌을 해결해야 하며 동시에 작업하든 하지 않든 작업 속도가 저하된다.

10. 조심해야 할 것은 MVC 패턴을 사용하더라도 프로그램에 객체 지향 설계가 적용되지 않은 경우 유지 보수에서 큰 효과가 없을 수 있다는 점이다. 하지만 많은 객체 지향 설계 방법론 중 MVC 만큼 이해가 간단(?)하면서 큰 효과를 보는 패턴도 적다고 생각한다.

## 12부 - Java Web에서의 MVC 패턴의 적용

1. Action 패턴은 계속 적용합니다.

2. Model 계층을 이루는 요소들
    1. View에서도 보여질 개체(Entity) = JSP에서 값을 접근하여 표시하는 데 사용되는 객체. 비 객체지향적 설계이지만 JSP에서 접근하는 내부 변수는 getter/setter가 필요함 (Java Beans 표준 때문에)

    2. DAO - Data Access Object - 데이터 접근 객체 = 데이터 입/출력을 추상화한/인터페이스를 정의하고 구현한 객체 - 비즈니스 로직에서 DB에 대한 내용을 몰라도 되도록 한다. :smile:

    3. Service - 서비스 - 개체가 할 수 없는 일을 진행하는 객체. 예: 개체를 생성하거나, 한 개체가 아닌 여러 개체가 참여하는 기능을 구현할 때는 제 3자가 처리해야 함.

3. DAO, Service 개체는 `Singleton 패턴`을 사용한다. `Singleton`은 하나의 객체를 프로그램 전체에서 참조해서 사용하는 객체인데, `Singleton`은 그래서 `속성(상태)`가 없어야 한다. `속성(상태)`라 함은 멤버 변수, 즉 인스턴스 변수가 있고, 그것이 사용될 때 상태를 가진다고 표현을 하고, `Singleton 패턴`은 상태가 없어야(stateless) 한다. (이유: `Singleton`은 `thread-safe`해야 하기 때문)

## 13부 - 리팩토링

1. Null을 반환하지 말고, Exception을 정의하여 활용하기

2. 한꺼번에 Exception을 처리하기 - FrontController

3. `return "redirect:/error.do";`가 중복되므로, 리팩토링 하기

4. [1] ~ [3]은 한 번에 해결할 수 있는 것 같음
